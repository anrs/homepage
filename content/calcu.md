Title: 过程和计算，线性递归和尾递归
Date: 2008-09-11 06:09
Category: blog
Summary: 

上次和 olio 提到了尾递归和线性递归的问题，今天仔细分解了一下。 首先是分清楚递归过程和递归计算这两个概念。前者论述的是语法形式，说明过程定义直接或间接调用了过程自身；后者则是说过程定义中的计算进展方式，而不是相应过程书写上的语法形式。因此，递归过程可能产生迭代的计算进展方式，也有可能产生递归的计算进展方式，这取决于你递归过程的书写形式。 上面几句有些抽象，用个例子说明就比较清楚了！下面是两种不同的计算进展方式的求解 n! 的递归过程

1. 递归计算进展方式的递归过程：

```erlang
(define (factorial n)
  (if (= n 1)
    1
    (* n (factorial (- n 1)))))
```

2. 迭代计算进展方式的递归过程：

```erlang
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
      product
      (iter (* counter product) (+ counter 1))))
  (iter 1 1))
```

在我用 erl 实现的第一种递归过程上，在计算到 40000! 时机器便不行了，明显迟滞；而 erl 实现的第二种递归过程上，除了依然能跑出结果外，连命令行都没有假死现象，而且速度明显比第一种更快！ 让我们来看下为什么为出现这两种不同的情况。在第一种我们称之为递归计算进展方式的递归过程中，我们要算出 n! 就必须先计算出 (n - 1)! 后再将计算结果乘上 n 得出要求的 n! 的值。比如在求 6! 时的代换过程如下：

```erlang
1. (factorial 6)
2. (* 6 (factorial 5))
3. (* 6 (* 5 (factorial 4)))
4. (* 6 (* 5 (* 4 factorial(3))))
5. (* 6 (* 5 (* 4 (* 3 factorial(2)))))
6. (* 6 (* 5 (* 4 (* 3 (* 2 factorial(1))))))
```

经过以上六步之后才算完成代换，之后是相应的归约过程：

```erlang
7. (* 6 (* 5 (* 4 (* 3 (* 2 1)))))
8. (* 6 (* 5 (* 4 (* 3 2))))
9. (* 6 (* 5 (* 4 6)))
10. (* 6 (* 5 24))
11. (* 6 120)
12. 720
```

可以看到整个计算进展的链条是非常之长的，并且每一步都必须被保存才能计算出相应的值，可以想见在这种情形下计算 40000! 所耗用的内存空间规模之巨。而在迭代计算进展方式的递归过程中，情况就简单得多了：

```erlang
(factorial 6)
(fact-iter 1 1 6)
(fact-iter 1 2 6)
(fact-iter 2 3 6)
(fact-iter 6 4 6)
(fact-iter 24 5 6)
(fact-iter 120 6 6)
(fact-iter 720 7 6)
720
```

综上所见，迭代计算过程就是那种状态（就像上面的 product/counter）可以用固定数目的状态变量描述的过程，而在递归计算过程中，这些状态（每一次调用时 n 的值）都被维护在运算链条中的某一段上。 最后，我们把迭代计算进展方式的递归类型称为尾递归，而把递归计算进展方式的递归类型称为线性递归。

p.s. 上面 Scheme 代码偶在 ubuntu8.10 上用 erl5.5.5 实现；但我在 WinXP + VS2005 上写同样的 C# 代码的话，尾递归反而比线性递归更耗时，甚至能计算出结果的阶乘值都比线性递归更小，不知道为什么会出现这种情况！

erl 的线性递归：

```erlang
fac(1) ->
  1;
fac(N) ->
  N * fac(N - 1).
```

erl 的尾递归：

```erlang
fac(N) ->
  fac_iter(1, 1, N).

fac_iter(Product, Counter, Max_Count) ->
  if
    Counter > Max_Count ->
      Product;
    true ->
      fac_iter(Product * Counter, Counter + 1, Max_Count)
  end.
```
