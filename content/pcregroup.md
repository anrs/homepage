Title: PCRE 之 ?> 锁定成功匹配的分组结果
Date: 2008-03-15 15:10
Category: blog
Summary:

标题有点拗口，寒一个的说。先看个不涉及到 ?> 的例子

```perl
my $txt = 'AK74';
$txt =~ /((\w*)(\d+))/i;
print $1;
```

打印结果是 AK74

Regex 引擎首先用 \w* 去匹配字符串 AK74，* 修饰符的最长匹配原则导致 \w* 匹配到了整个字符串 AK74，接着 \d+ 上场匹配，由于 + 修饰符要求至少匹配一次，为大局考虑，\w* 不得不吐出一个已匹配到的字符 4 以满足 \d+ 的要求，所以最后结果就是 \w* 匹配到 AK7 而 \d+ 也成功匹配到了字符 4

如果我们期望前面的分组匹配成功之后，无论其后匹配状况如何都不再吐出已匹配的结果，那就可以使用 ?> 将分组中已匹配成功的结果锁定。

```perl
my $txt = 'AK74';
$txt =~ /((?>\w*)(\d+))/i;
print $1;
```

运行上面的代码将收到“使用了未初始化值”的错误提示。

同未使用 ?> 的 Regex 表达式一样，\w* 首先匹配到了整个字符串 AK74，接着 \d+ 上场匹配，+ 要求 \w* 至少吐出一个字符以满足匹配，但是 ?> 却自私的将 \w* 的匹配结果锁定，即 \w* 并没有吐出任何字符，仍然保留整个 AK74 字符串，结果导致 \d+ 匹配失败，最终整个 Regex 表达式匹配失败，所以打印 $1 时收到了错误提示。

显而易见 ?> 并不锁定失败的匹配结果，失败的匹配或空匹配也没什么需要锁定的内容

```perl
my $txt = 'AK74';
$txt =~ /((?>(MP5)*)(\d+))/i;
print $1;
```

打印结果是 74

因为 $txt 值中并不包含 MP5 字符串，所以一开始，(MP5)* 就匹配失败，接着 \d+ 上场匹配，跳过 AK 后，成功获得字符串 74，由于 * 修饰符允许空匹配，所以整个 Regex 表达式匹配成功。

ps.  昨天把脖子拧了，睡觉还落枕，呀呀个呸的，今天只歪起脑壳做人了